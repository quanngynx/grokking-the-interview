# Intuition

We need to compute, for each user, the total distance they have traveled across all rides and then sort users by that total distance (and by name when distances are equal). Users with no rides must still appear with a total travelled distance of 0.

## Approach

- **Join users and rides**: Use a `LEFT JOIN` from `Users` to `Rides` so that users without rides are still included.
- **Handle missing rides**: Distances for users without rides will be `NULL`, so we wrap the `SUM` with `COALESCE` to convert `NULL` to `0`.
- **Aggregate per user**: Group by the user identifier (and name) to compute the total distance per user.
- **Ordering**: Order the final result by total distance in descending order, and for ties order by user name in ascending order.

## Complexity

- **Time complexity**: \(O(N)\), where \(N\) is the number of rides, since we scan and aggregate the `Rides` table once (plus a linear join with `Users`).
- **Space complexity**: \(O(U)\) for the result set, where \(U\) is the number of users; extra memory used by the query engine is \(O(1)\) beyond that.

## Edge Cases

- **User with no rides**: A user present in `Users` but with no matching rows in `Rides` should appear with `travelled_distance = 0` (ensured by `LEFT JOIN` + `COALESCE` / `CASE`).
- **Multiple rides per user**: Distances across all rides for the same user must be summed correctly; no double-counting or missing rides.
- **All users with zero total distance**: When every user has `travelled_distance = 0`, the ordering falls back entirely to ascending user name.
- **Large distances or many rides**: Summation should still work correctly without overflow in the chosen SQL dialect and data type (e.g., use an appropriate integer type).
- **Ties on distance**: When users share the same total distance, verify that the secondary sort by `name` ascending is correctly applied.

## Code

```sql
-- PostgreSQL
SELECT u.name, COALESCE(SUM(r.distance), 0) AS travelled_distance
FROM Users u
LEFT JOIN Rides r 
ON u.id = r.user_id
GROUP BY u.id, u.name
ORDER BY travelled_distance DESC, u.name ASC;

-- MySQL
SELECT u.name, SUM(CASE WHEN u.id = r.user_id then r.distance ELSE 0 END) AS travelled_distance
FROM users u
LEFT JOIN rides r 
ON u.id = r.user_id
GROUP BY u.id, u.name
ORDER BY travelled_distance DESC, u.name ASC;
```
