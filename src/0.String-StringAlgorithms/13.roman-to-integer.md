# Intuition

Roman numerals encode numbers using specific symbols with fixed values, sometimes using a smaller value before a larger one to indicate subtraction (like `IV = 4`). To convert a Roman numeral to an integer efficiently, we can scan the string and decide at each position whether to add or treat it as part of a subtractive pair based on the next symbol.

## Approach

1. Create a lookup map from each Roman character to its integer value.
2. Iterate through the string from left to right using an index `i`.
3. For each character, compare its value with the value of the next character (if it exists):
   - If the current value is **less than** the next value, this is a subtractive pair (e.g., `IV`, `IX`), so add `next - current` to the result and skip the next character by incrementing `i` an extra time.
   - Otherwise, just add the current value to the result.
4. Continue until the end of the string and return the accumulated result.

## Complexity

- Time complexity: \(O(n)\), where \(n\) is the length of the input string `s`, since we scan each character at most once.
- Space complexity: \(O(1)\), because the lookup map has a constant number of entries and we use a fixed amount of extra state.

## Edge Cases

- **Single-symbol numerals**: Inputs like `I`, `V`, `X` should still work correctly with the same logic.
- **Largest values**: Numerals near the upper bound like `MMMCMXCIX` (3999) test repeated addition plus subtractive pairs.
- **Only additive notation**: Strings like `VIII` or `XVII` where values never decrease should just be a straight sum of symbols.
- **Only subtractive pairs**: Inputs such as `IV`, `IX`, `XL`, `CM` ensure we handle the `current < next` logic correctly.
- **Mixed additive and subtractive**: Typical cases like `MCMXCIV` combine both patterns and validate skipping the second symbol of each subtractive pair.

## Code

```typescript
function romanToInt(s: string): number {
  const romanToIntMap: Record<string, number> = {
    I: 1,
    V: 5,
    X: 10,
    L: 50,
    C: 100,
    D: 500,
    M: 1000,
  }

  let result = 0

  for (let i = 0; i < s.length; i++) {
    const current = romanToIntMap[s[i]]
    const next = romanToIntMap[s[i + 1]]

    if (next !== undefined && current < next) {
      result += next - current
      i++
    } else {
      result += current
    }
  }

  return result
}
```
